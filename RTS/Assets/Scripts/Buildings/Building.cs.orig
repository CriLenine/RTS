using System.Collections;
using System.Collections.Generic;
using UnityEngine;

<<<<<<< HEAD:RTS/Assets/Scripts/RÃ©mi/RBuilding.cs
public enum PeonBuilds
{
    Farm,
    Barracks,
    Ressourcesoutpost
}

public abstract class RBuilding : TickedBehaviour, IDamageable
=======
public abstract class Building : TickedBehaviour, IDamageable
>>>>>>> rdufosse/ressources:RTS/Assets/Scripts/Buildings/Building.cs
{
    [SerializeField]
    private bool _isBuilt = false;

    [SerializeField]
    private BuildingData _buildingData; //USE ?

    [SerializeField]
    private int _currentWorkforce;

    [SerializeField]
    private int _currentHealth;

    /*Ici on aura les options disponibles en cliquant sur un bâtiment
     * (ex créer une certaine unité dans une caserne)*/
    //[SerializeField]
    //private List<Option> _options;

    public BuildingData Data => _buildingData;

    public int MaxHealth => _buildingData.MaxHealth;
<<<<<<< HEAD:RTS/Assets/Scripts/RÃ©mi/RBuilding.cs
    public float CurrentWorkforceRatio => _currentWorkforce / _buildingData.TotalWorkforce;
    public float CurrentHealth => _currentHealth / MaxHealth;

    //SpriteManagement
    private SpriteRenderer _buildingRenderer;
    private int _actualSpriteIndex;
    private float _ratioStep;
    //

    private void Start()
    {
        _buildingRenderer = GetComponent<SpriteRenderer>();

        _ratioStep = _buildingData.TotalWorkforce / (_buildingData.ConstructionSteps.Length);
        _actualSpriteIndex = 0;
    }
    /// <returns><see langword="true"/> if it finishes the building's construction,
    /// <see langword="false"/> otherwise </returns>

=======

    public float CurrentWorkforce => _currentWorkforce / _buildingData.TotalWorkforce;

    public float CurrentHealth => _currentHealth / MaxHealth;

    /// <returns><see langword="true"/> if it finishes the building's construction,
    /// <see langword="false"/> otherwise </returns>
>>>>>>> rdufosse/ressources:RTS/Assets/Scripts/Buildings/Building.cs
    public bool AddWorkforce(int amount)
    {
        if (_isBuilt)
            return true;

        _currentWorkforce += amount;

        //Change sprite 
        int spriteIndex=0;
        
        for (int i = 0; i < _buildingData.ConstructionSteps.Length; i++)
        {
            spriteIndex = _currentWorkforce > (i * (_ratioStep)) ? i:spriteIndex ;
        }

        if(spriteIndex != _actualSpriteIndex)
        {
            _buildingRenderer.sprite = _buildingData.ConstructionSteps[spriteIndex];
            _actualSpriteIndex = spriteIndex;
        }

        //

        if (CurrentWorkforceRatio >= 1f)
        {
            //addBuildingToLogicalTileMap
            int oC = 0;
            for (float i = 0.5f * TileMapManager._tileSize; i < _buildingRenderer.bounds.extents.x; i += TileMapManager._tileSize)
            {
                oC++;
            }
            TileMapManager.AddBuilding(oC);
            //

            _currentWorkforce = _buildingData.TotalWorkforce;
            _isBuilt = true;
        }
        return _isBuilt;
    }
}